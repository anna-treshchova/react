                                                                                                                      /*
                                                  React
                                                ‾‾‾‾‾‾‾‾
                               це JS-бібліотека для створення інтерфейсів (UI)

 UI (User Interface) — це все, що бачить і з чим взаємодіє користувач на веб-сторінці (кнопки, інпути, меню, форми,
 списки, повідомлення тощо)

 React дозволяє будувати інтерфейси з компонентів, які можна повторно використовувати

 Розроблена компанією Meta (Facebook)


                  ПІДХІД: компонентний
‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾

 Компонентний підхід у React означає, що весь інтерфейс (UI) розділяється на маленькі незалежні частини, які називаються
 компонентами

 Кожен компонент — це окрема, багаторазова частина сторінки: кнопка, картка, форма, список, заголовок тощо


                                     REACT МАЄ ДВА ОСНОВНИХ ТИПИ КОМПОНЕНТІВ:

 1. Класові компоненти (Class Components) — застарівають

     ◦ це компоненти, створені за допомогою JavaScript-класів

     ◦ вони були основними до появи хуків у 2019 році

     ◦ мають стан (this.state) і методи життєвого циклу


 2. Функціональні компоненти (Function Components) — сучасний стандарт

    Це звичайні JavaScript-функції, які повертають JSX. Можуть використовувати хуки (наприклад, useState, useEffect)


‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾
 Компонент — це функція або клас, яка повертає частину інтерфейсу (тобто HTML-подібний блок у синтаксисі JSX)

 Тобто компонент — це шматок UI, написаний у вигляді функції або класу
‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾


                           ЯК ЗРОЗУМІТИ, ЩО ЧАСТИНУ ВАРТО ВИНЕСТИ В ОКРЕМИЙ КОМПОНЕНТ:

 1. Повторюється один і той самий блок коду
    Якщо ми бачимо однакову HTML-структуру (JSX) кілька разів — це точно треба винести в окремий компонент

 2. Блок має свою окрему логіку або стан
    Якщо частина інтерфейсу має власну поведінку (наприклад, натискання кнопки, зміна тексту, перевірка форми) — це
    окремий компонент

 3. Великий JSX-код у одному компоненті
    Якщо компонент стає громіздким і важко читається, треба розбити його на менші компоненти

    НАПРИКЛАД: форма, список, кнопка — усе разом  —→  краще зробити на компоненти: <Form />, <TodoList />, <Button />

 4. Блок має чітке призначення
    Якщо в інтерфейсі є логічно окрема частина (наприклад, картка товару, заголовок, навігація) — це окремий компонент

 5. Ми хочемо повторно використати блок в іншому місці
    Якщо ми плануємо використати той самий елемент на різних сторінках або в різних місцях — це окремий компонент


                                           ТИПОВІ ПРИКЛАДИ ОКРЕМИХ КОМПОНЕНТІВ

  Назва компонента      Опис                                                               Приклад вигляду
└──────────────────┘────────────────────────────────────────────────────────────────────┘────────────────────────────────────────┘
  Header           │ Верхня частина сторінки з логотипом, меню, кнопками входу          │  <Header />                            │
                   │                                                                    │                                        │
  Footer           │ Нижня частина сторінки                                             │  <Footer />                            │
                   │                                                                    │                                        │
  Button           │ Кнопка з однаковим стилем, яку можна багаторазово використовувати  │  <Button text="Click" />               │
                   │                                                                    │                                        │
  InputField       │ Поле вводу з лейблом й (можливо) повідомленням про помилку         │  <InputField label="Name" />           │
                   │                                                                    │                                        │
  TodoItem         │ Один елемент задачі у списку                                       │  <TodoItem text="Buy milk" />          │
                   │                                                                    │                                        │
  TodoList         │ Увесь список задач                                                 │  <TodoList items={todos} />            │
                   │                                                                    │                                        │
  Modal            │ Модальне вікно                                                     │  <Modal title="Confirmation" />        │
                   │                                                                    │                                        │
  ProductCard      │ Картка товару в магазині                                           │ <ProductCard product={product} />      │
                   │                                                                    │                                        │
  NavBar           │ Навігація по сайту (меню)                                          │ <NavBar />                             │
                   │                                                                    │                                        │
  Form             │ Форма з кількох інпутів і кнопкою                                  │ <LoginForm /> або <AddTodoForm />      │
└──────────────────┘────────────────────────────────────────────────────────────────────┘────────────────────────────────────────┘


                                           REACT ПРИНЦИПИ:
                                         ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾

 1. ОДИН КОМПОНЕНТ — ОДНА ВІДПОВІДАЛЬНІСТЬ

     ◦ Кожен компонент має відповідати лише за одну конкретну частину інтерфейсу або одну логіку

     ◦ Це називається SRP (Single Responsibility Principle) — принцип єдиної відповідальності

     ◦ Якщо компонент робить забагато — його потрібно розбити на менші компоненти

 2. SPA (Single Page Application - односторінковий застосунок)

     ◦ React дозволяє створювати односторінкові застосунки — коли вся логіка відбувається на одній сторінці, без повного
       перезавантаження. Тобто усі сторінки сайту живуть в одному HTML-файлі — index.html

     ◦ Коли користувач "переходить між сторінками" — React не завантажує нову сторінку з сервера (бо в нас її немає)
       Він просто оновлює потрібну частину DOM — показує інший компонент на тій же сторінці, не перезавантажуючи її



                        СИНТАКСИС: JSX
‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾
 У React для написання компонентів використовується JSX (JavaScript XML). Це розширення JS синтаксису, яке дозволяє
 писати HTML-подібний код прямо всередині JavaScript

 Але браузер не розуміє JSX напряму, бо це не стандартний JavaScript, а спеціальний синтаксис React. Тому JSX потрібно
 трансформувати в звичайний JavaScript

 Це робить Babel (трансформатор коду, який перетворює JSX у звичайний JavaScript)


                          ОСНОВНА ІДЕЯ
‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾
 Замість того, щоб постійно змінювати DOM вручну, React дозволяє:

  1. Описати, як має виглядати інтерфейс (у вигляді компонентів)

  2. Й сам оновлює тільки ті частини сторінки, які змінилися — це віртуальний DOM. Швидкий рендеринг завдяки Virtual DOM


‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾

                                                    Virtual DOM
                                                  ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾

 Virtual DOM — це уявна модель інтерфейсу, створена React у вигляді об'єктів JavaScript, яка зберігається в оперативній
 памʼяті (RAM)

 На її основі React створює реальний DOM при першому рендері, й надалі порівнює попередній Virtual DOM з New Virtual DOM,
 щоб визначити зміни та оновити лише ті частини реального DOM, які змінилися


 Тобто React:
‾‾‾‾‾‾‾‾‾‾‾‾‾‾
   1. Спочатку будує дерево компонентів у Virtual DOM

   2. На його основі створює реальний DOM і вставляє у браузер

   3. При зміні стану або пропсів — створює новий Virtual DOM

   4. Порівнює новий Virtual DOM зі старим

   5. Визначає, які саме елементи змінилися

   6. Оновлює тільки змінені частини реального DOM


                                       Детально як React працює з Virtual DOM:
                                      ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾

 1. Перший рендер (при запуску застосунку):

      ◦ React створює Virtual DOM з нуля на основі свого внутрішнього стану і компонентів

      ◦ Virtual DOM — це внутрішнє представлення UI у вигляді дерева JS-об’єктів

      ◦ Це відображення того, як має виглядати справжній DOM, але воно існує тільки в пам’яті, а не в браузері


 2. Virtual DOM не базується на реальному DOM

      ◦ React не базується на існуючому реальному DOM браузера — він створює Virtual DOM з наших React-компонентів

      ◦ Реальний DOM зазвичай містить лише один рядок коду: <div id="root"></div>


 3. Рендеринг Virtual DOM у реальний DOM
      React рендерить цей Virtual DOM у реальний DOM — вставляє потрібні елементи у браузер, щоб користувач їх бачив


 4. Оновлення стану: створення нового Virtual DOM
      Коли стан (state) або пропси (props) змінюються, React знову створює новий Virtual DOM


 5. Реконсиляція (Reconciliation): порівняння Virtual DOM
      React порівнює новий Virtual DOM зі старим (цей процес називається реконсиляція)


 6. Визначення змін (Diffing)
      React визначає різниці (diff) між старим і новим Virtual DOM


 7. Оновлення реального DOM
      React оновлює в реальному DOM тільки ті частини, які змінилися


 ПІДСУМОК:

   ◦ React створює Virtual DOM як набір JavaScript-об’єктів у пам’яті

   ◦ Ці об’єкти — це внутрішнє представлення UI, яке React використовує для порівняння та оновлення реального DOM

   ◦ Virtual DOM — це не частина браузера і не видима частина сторінки, це просто дані в оперативній пам’яті,
     якими керує React


┌───────────────────────────────────────────────────────────────────────┬─────────────────────────────────────────────────────────┬────────────────────────────────────────────┐
│                       1. Virtual DOM (React)                          │              2. Browser DOM — дерево вузлів             │      3. HTML (після рендерингу React)      │
├───────────────────────────────────────────────────────────────────────┼─────────────────────────────────────────────────────────┼────────────────────────────────────────────┤
│                                                                       │                                                         │                                            │
│  const root = {                                                       │   Document                                              │   <html>                                   │
│    type: 'div',                                                       │   └── <html>                                            │     <body>                                 │
│    props: { id: 'root' },                                             │       └── <body>                                        │       <div id="root">                      │
│    children: [                                                        │           └── <div id="root">                           │         <div>   ←— <App />                 │
│      {                                                                │               └── <div>    ←— <App />                   │           <div>    ←— <FirstComponent />   │
│        type: 'div',        ←— <App />                                 │                   └── <div>    ←— <FirstComponent />    │             <h1>Hello, world!</h1>         │
│        props: {},                                                     │                       ├── <h1>Hello, world!</h1>        │             <button>Click me!</button>     │
│        children: [                                                    │                       └── <button>Click me!</button>    │           </div>                           │
│          {                                                            │                                                         │         </div>                             │
│            type: 'div',    ←— <FirstComponent />                      │                                                         │       </div>                               │
│            props: {},                                                 │                                                         │      </div>                                │
│            children: [                                                │                                                         │   </body>                                  │
│              { type: 'h1', props: {}, children: ['Hello, world!'] },  │                                                         │ </html>                                    │
│              { type: 'button', props: {}, children: ['Click me!'] }   │                                                         │                                            │
│            ]                                                          │                                                         │                                            │
│          }                                                            │                                                         │                                            │
│        ]                                                              │                                                         │                                            │
│      }                                                                │                                                         │                                            │
│    ]                                                                  │                                                         │                                            │
│  }                                                                    │                                                         │                                            │
└───────────────────────────────────────────────────────────────────────┴─────────────────────────────────────────────────────────┴────────────────────────────────────────────┘


                                                     RAM
                                                  ‾‾‾‾‾‾‾‾

 RAM (Random Access Memory) — це оперативна (або тимчасова) пам’ять, яку використовує комп’ютер (або телефон), щоб
 зберігати дані та програми, які зараз активно працюють


 ЯК ПРАЦЮЄ RAM:
                1. Коли ми вмикаємо компʼютер — операційна система завантажується в RAM

                     1.1   Ми натискаємо кнопку ввімкнення

                     1.2  Система на материнській платі запускає операційну систему з диска
                          Операційна система (ОС) — це головна програма, яка керує всім комп’ютером або смартфоном

                     1.3  ОС завантажується в оперативну памʼять (RAM), бо тільки там програми можуть працювати

                     1.4  З’являється робочий стіл або екран телефону — тепер ми можемо користуватись пристроєм

                2. Коли ми відкриваємо браузер, гру, документ — їх код і дані теж потрапляють у RAM

                3. Після вимкнення компʼютера вся інформація в RAM зникає — бо вона тимчасова


 EXAMPLE:
            ◦ Ми відкрили браузер  —→  частина RAM зайнята браузером

            ◦ Відкрили сайт —→  ще частина RAM зайнята сторінкою, картинками, скриптами

            ◦ Відкрили гру —→ ще більше RAM


 Якщо RAM не вистачає — компʼютер починає гальмувати, бо змушений переміщати дані між RAM та файлом підкачки

 ТОБТО коли оперативної памʼяті (RAM) не вистачає, компʼютер:

     ◦ переміщує частину даних із RAM на диск (на SSD або HDD) — у спеціальний файл підкачки (page file, swap file)

     ◦ потім за потреби знову переносить їх назад у RAM

 Це набагато повільніше, ніж просто зберігати все в RAM → саме тому компʼютер починає гальмувати


                                                     ROM
        и                                          ‾‾‾‾‾‾‾‾

 ROM (Read-Only Memory) — це постійна памʼять, в якій зберігаються важливі інструкції та в яку записують дані один раз
 (або дуже рідко), і вона не зникає після вимкнення компʼютера

 ЩО ЗБЕРІГАЄТЬСЯ В ROM:

    ◦ BIOS / UEFI — програма, яка запускає комп’ютер при ввімкненні

    ◦ Інструкції для ввімкнення процесора, перевірки пам’яті, вибору з чого завантажуватись


‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾


 БІБЛІОТЕКА (Library) — це набір готових функцій, класів, компонентів, які ми можемо використовувати у своєму коді

     ◦ Структура директорій, створення функцій і компонентів залежить від нас

     ◦ Ми самі вирішуємо, де і як розміщувати код

     ◦ Бібліотека дає інструменти, а ми керуємо організацією і підходами

   ПРИКЛАД: React — це бібліотека для створення UI



 ФРЕЙМВОРК (Framework) — це структура або каркас, у якому ми будемо писати свій код

      ◦ Структура директорій і написання функцій/компонентів жорстко регламентовані

      ◦  Потрібно дотримуватися встановлених правил і стандартів

      ◦ Наприклад, в цій папці повинні жити компоненти, функції треба писати так, інакше програма не працюватиме

      ◦ Фреймворк задає каркас і контролює, як має бути побудований код

   ПРИКЛАД: Angular — це фреймворк, який задає структуру, правила і компоненти для створення веб-застосунку


‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾

                                                  RENDERING
                                                ‾‾‾‾‾‾‾‾‾‾‾‾‾

 Рендеринг — це процес перетворення даних у видимий інтерфейс (сторінку з кнопками, текстом, зображеннями тощо)

 Існують різні місця, де може відбуватись рендеринг:

      ◦ НА СЕРВЕРІ (Server-Side Rendering) — ще до того, як сторінка потрапляє до браузера
        Сервер формує повний HTML з усім контентом і відправляє його користувачу

      ◦ НА КЛІЄНТІ (Client-Side Rendering) — після того, як сторінка завантажилася в браузері
        JavaScript самостійно збирає контент, формує інтерфейс і додає функціональність



 1.                                        Client-Side Rendering (CSR)
‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾

 CSR (рендеринг на стороні клієнта) — браузер отримує мінімальний HTML, а весь контент сторінки формується JavaScript-ом
 на клієнті (в браузері користувача) після завантаження сторінки


 ЯК ПРАЦЮЄ:
‾‾‾‾‾‾‾‾‾‾‾
   1. Клієнт надсилає запит на отримання сторінки

   2. Сервер відповідає мінімальним HTML-файлом в якому лише

       ◦ <div id="root"></div> — контейнер для майбутнього інтерфейсу

       ◦ підключений JS-файл (наприклад index.js)

   3. Браузер завантажує JS-файл й створює DOM на основі цього HTML → тобто в DOM на початку є лише <div id="root">

   5. Після цього запускається JavaScript, який:

       ◦ довантажує необхідні дані (наприклад, через API)

       ◦ створює елементи інтерфейсу

       ◦ вставляє їх у DOM

   6. В результаті DOM оновлюється — і в ньому з’являється повний інтерфейс: текст, кнопки, форми тощо


 ВИСНОВОК:
‾‾‾‾‾‾‾‾‾‾
     ◦ Увесь інтерфейс формується в браузері користувача за допомогою JavaScript

     ◦ HTML-файл, отриманий від сервера, містить лише основу — усе решта додається динамічно


 ПЛЮСИ:
‾‾‾‾‾‾‾
     ◦ Висока інтерактивність після першого завантаження

     ◦ Менше навантаження на сервер

     ◦ Чудово підходить для SPA (Single Page Applications) — застосунків з однією сторінкою

     ◦ Динамічне оновлення контенту без перезавантаження сторінки (через JavaScript)


 МІНУСИ:
‾‾‾‾‾‾‾‾
     ◦ Повільне перше завантаження (FCP — First Contentful Paint): користувач довше чекає появу контенту

     ◦ SEO-проблеми: пошукові системи можуть не побачити контент, якщо він формується динамічно через JS

     ◦ Вразливість до вимкненого JavaScript — без нього сторінка може не працювати взагалі



 2.                                        Server-Side Rendering (SSR)
‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾

 SSR (рендеринг на стороні сервера) — контент формується на сервері, тобто сервер створює повний HTML, і браузер відразу
 його відображає


 ЯК ПРАЦЮЄ:
‾‾‾‾‾‾‾‾‾‾‾
     1. Клієнт запитує сторінку

     2. Сервер обробляє запит, й сам збирає повноцінну HTML-сторінку з усім текстом і даними й надсилає браузеру

     3. Браузер просто показує вже готову сторінку — як картинку, яку не треба складати

     4. Додатково може підключатися JavaScript для інтерактивності


 ПЛЮСИ:
‾‾‾‾‾‾‾
     ◦ Швидкий перший рендеринг (користувач одразу бачить контент)

     ◦ SEO-дружній — пошуковики бачать повний HTML

     ◦ Менше залежності від JavaScript


 МІНУСИ:
‾‾‾‾‾‾‾‾
     ◦ Більше навантаження на сервер (особливо при великому трафіку)

     ◦ Повільніша навігація між сторінками (якщо не використовуються SPA-методи)

     ◦ Складніша організація при додаванні інтерактивності



                     Характеристика         Client-Side Rendering (CSR)    Server-Side Rendering (SSR)
               └─────────────────────────┘──────────────────────────────┘──────────────────────────────┘
               │ Місце рендерингу        │ Браузер                      │ Сервер                       │
               │                         │                              │                              │
               │ Перший показ (FCP)      │ Повільний                    │ Швидкий                      │
               │                         │                              │                              │
               │ SEO                     │ Слабкий                      │ Сильний                      │
               │                         │                              │                              │
               │ Навантаження на сервер  │ Низьке                       │ Високе                       │
               │                         │                              │                              │
               │ UX після завантаження   │ Дуже плавний (SPA)           │ Може бути перезавантаження   │
               │                         │                              │                              │
               │ Підтримка JavaScript    │ Обов’язкова                  │ Може працювати навіть без JS │
               └─────────────────────────┘──────────────────────────────┘──────────────────────────────┘



 3.                                         Гібридний підхід (Next.js)
‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾

 Головна особливість Next.js — використання чанків для маршрутизації

     ◦ Маршрутизація — це процес відповідності URL (endpoint) конкретній сторінці або компоненту, який має бути
       показаний користувачу

     ◦ Next.js автоматично створює окремі JavaScript-файли (чанки) під час збірки проєкту

     ◦ Кожна сторінка проєкту — це окремий чанк

     ◦ При переході між сторінками Next.js підвантажує лише потрібний чанк — тобто лише JS-код потрібної сторінки

     ◦ Це забезпечує швидке початкове завантаження (завдяки SSR) і плавну навігацію без повного оновлення сторінки
       (завдяки CSR)


  ЯК ПРАЦЮЄ:
‾‾‾‾‾‾‾‾‾‾‾
   1. Клієнт надсилає запит на отримання сторінки (наприклад, /about)

   2. Сервер отримує запит, збирає HTML саме для цієї сторінки, використовуючи відповідний JS-чанк, і відправляє готову
      сторінку клієнту

      ТОБТО ВІДПОВІДЬ ВІД СЕРВЕРА МІСТИТЬ:

          2.1  Повний HTML сторінки /about зі стилями (CSS), згенерований на сервері

          2.2  JS-чанк для /about — код цієї сторінки (React компоненти, обробники подій, API-запити, тощо)

          2.3  Спільні чанки (ті, що потрібні для роботи React та загального коду)

               ◦ main.js — загальний код, який використовується на різних сторінках:

                     • утиліти (функції, які імпортуються в кількох компонентах)
                     • спільні компоненти інтерфейсу (хедер, футер)

               ◦ framework.js (React і залежності) — містить сам фреймворк React та всі його залежності.

          ЦЕ МІНІМАЛЬНИЙ НАБІР ФАЙЛІВ ДЛЯ ПОВНОЦІННОЇ РОБОТИ СТОРІНКИ


   3. На цьому етапі працює Server-Side Rendering (SSR):

          3.1  Браузер отримує повністю згенеровану, але ще не інтерактивну HTML-сторінку

          3.2  Й йому залишається просто відобразити цю сторінку — як картинку, яку не треба складати


   4. ГІДРАЦІЯ СТОРІНКИ (hydration)

      Після того як на основі HTML-коду браузер створив DOM, підвантажується JS, й React:

          4.1  Знаходить HTML-елементи в DOM

          4.2  Прикріплює до них свою логіку (наприклад, що кнопка при кліку щось змінює)

          4.3  Активує хуків (useState, useEffect, тощо)

          4.4  РЕЗУЛЬТАТ: сторінка оживає — усе стає інтерактивним


         ПІДСУМОК: Це і є hydration — зволоження статичного HTML реактивністю:

             ◦ СПОЧАТКУ: ми бачимо сторінку, але вона мертва — нічого не працює

             ◦ ПОТІМ: приходить JavaScript  —→  React гідрує DOM  —→  все оживає: кліки, інпути, анімації


      КОЛИ ВІДБУВАЄТЬСЯ ГІДРАЦІЯ:

          ◦ При SSR — щоразу, коли сторінка рендериться на сервері, клієнт отримує готовий HTML —→ потім відбувається
            hydration

          ◦ При гібридному рендерингу (як у Next.js) — тільки при першому завантаженні. Далі переходи між сторінками
            обробляються на клієнті (CSR), і hydration не повторюється


   5. Далі (при кліках на <Link>) сторінки перезбираються на стороні клієнта

      Тобто при кліку на іншу сторінку відбувається запит до сервера:

          5.1  Браузер запитує лише JS-файл (чанк) необхідної сторінки

               Спільні файли (main.js, framework.js) — вже знаходяться в кеші браузера, тому повторно не завантажуються

          5.3  Завантажений чанк містить код сторінки (React-компонент)

          5.4. React динамічно оновлює DOM у браузері, використовуючи цей код
               (тобто створює та вставляє нові елементи без перезавантаження сторінки)

          5.3  HTML при цьому не запитується знову із сервера — усе оновлення відбувається на клієнті (CSR)


 ЗАВДЯКИ ЦЬОМУ:
‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾
         ◦ Перша сторінка швидка та SEO-дружня (SSR)

         ◦ Навігація між сторінками — без повного оновлення сторінки (CSR)


‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾

 npx (Node Package Execute) — це утиліта, яка дозволяє запускати Node-пакети без попередньої глобальної установки

 Вона йде в комплекті з npm  (починаючи з версії 5.2.0 — 2017 рік)


 ЯК ПРАЦЮЄ: Щоб виконати команду з пакета, не встановлюючи його вручну, використовується утиліта npx, вона:

     ◦ тимчасово завантажує пакет із npm

     ◦ виконує потрібну команду

     ◦ після завершення видаляє цей пакет з системи


‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾

                                                     PROPS
                                                  ‾‾‾‾‾‾‾‾‾‾
 ЩО ЦЕ:
        ◦ props (properties) — це дані, які передаються у компонент ззовні, зазвичай від батьківського компонента

        ◦ класовому компоненті вони доступні через this.props

 ПРИЗНАЧЕННЯ: props використовують для передачі даних у дочірні компоненти

 ОСОБЛИВОСТІ:
        ◦ компонент не може змінювати props! Вони лише для читання

        ◦ якщо потрібно змінити props, це робить батьківський компонент, передаючи нові значення

 ПРИКЛАД:

 class Greeting extends React.Component {
   render() {
     return <h1>Hello, {this.props.name}!</h1>;
   }
 }

 <Greeting name="Anna" />  ——→  name — це пропс, який приходить у компонент Greeting ззовні


У компоненті не обов’язково писати constructor(props) і передавати props у super(props), якщо ми не використовуємо state

‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾

                                                    STATE
                                                 ‾‾‾‾‾‾‾‾‾‾‾

 ЩО ЦЕ: state — це внутрішній стан компонента:

      ◦ це звичайний об'єкт, властивості якого — це внутрішні змінні, які компонент зберігає всередині себе і може
        змінювати під час своєї роботи (тобто state — це сховище внутрішніх змінних компонента)

      ◦ в класовому компоненті state задається в конструкторі як this.state = {}


 ПРИЗНАЧЕННЯ: state використовують для відстеження змін, які:

      ◦ впливають на вигляд чи поведінку компонента

      ◦ автоматично трегирять відмалювання New Virtual DOM

      ◦ що, в свою чергу, призводить до оновлення реального DOM (лише в тих місцях, де були зміни)


 ОСОБЛИВОСТІ:
       ◦ state треба змінювати через спеціальний метод this.setState()

         this.setState() може приймати:

            • об’єкт — для простого оновлення:   this.setState({ count: 1 });

            • функцію — коли новий стан залежить від попереднього:   this.setState(prev => ({ count: prev.count + 1 }));


       ◦ пряме присвоєння (наприклад, this.state.count = 1) не викликає оновлення компонента

       ◦ зміна стану викликає повторний виклик методу render() і оновлення UI


 ПРИКЛАД:

   class Counter extends React.Component {
     constructor(props) {
       super(props);
       this.state = { count: 0 };
     }

     increment = () => {
       this.setState({ count: this.state.count + 1 });
     }


     render() {
       return (
         <div>
           <p>Count: {this.state.count}</p>
           <button onClick={this.increment}>+</button>
         </div>
       );
     }
   }


 ПІДСУМОК:
                   Характеристика                    Props                             State
          └────────────────────────────┘─────────────────────────────────┘───────────────────────────────────┘
          │ Хто керує?                 │ Ззовні (батьківський компонент) │ Компонент сам (всередині)         │
          │                            │                                 │                                   │
          │ Можна змінювати            │ Ні (тільки для читання)         │ Так                               │
          │                            │                                 │                                   │
          │ Використання               │ Передача даних у компонент      │ Зберігання змінних, що змінюються │
          │                            │                                 │                                   │
          │ Викликає повторний рендер? │ Ні, лише якщо змінюються ззовні │ Так                               │
          └────────────────────────────┘─────────────────────────────────┘───────────────────────────────────┘


‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾*/


