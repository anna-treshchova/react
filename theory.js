                                                                                                                      /*
                                         React Class Component Lifecycle
                                       ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾
                                    Життєвий Цикл Класового React-Компонента


 Компонент проходить 3 основні фази життєвого циклу: монтуваня, оновлення, демонтування

 Кожна фаза життєвого циклу компонента має свої життєві методи (lifecycle methods)

 React надає можливість використати ці методи, й автоматично викликає їх у відповідний момент, якщо ми явно реалізували
 їх у своєму компоненті

 Методи, які не були реалізовані у компоненті, React просто пропускає



    1. Монтування (mounting) — компонент створюється та вставляється в DOM

         Методи:

            1.1  constructor() — не є методом життєвого циклу React-компонента

                 Це стандартний метод класів JavaScript, який викликається автоматично при створенні екземпляра класу

                 Хоча constructor не входить до React lifecycle методів, він виконується найпершим на початку фази
                 монтування — саме під час створення компонента

                 React використовує constructor як точку входу для ініціалізації компонента: тут зазвичай ініціалізують
                 state й за потреби: зберігають props у state та прив’язують методи


            1.2  static getDerivedStateFromProps(props, state)

            1.3  render()                                                 —→  Створюється новий Virtual DOM

─────────────
            1.4  React порівнює старий Virtual DOM vs новий Virtual DOM   —→   Diffing

            1.5  React оновлює реальний DOM
─────────────

            1.6  componentDidMount()



    2. Оновлення (updating) — компонент перерендерюється, коли змінюються state або props

         Методи:

            2.1  static getDerivedStateFromProps(props, state)

            2.2  shouldComponentUpdate(nextProps, nextState)

            2.3  render()                                                 —→  Створюється новий Virtual DOM

            2.4  getSnapshotBeforeUpdate(prevProps, prevState)            —→   Ще маємо доступ до старого DOM

─────────────
            2.5  React порівнює старий Virtual DOM vs новий Virtual DOM   —→   Diffing

            2.6  React оновлює реальний DOM
─────────────

            2.7  componentDidUpdate(prevProps, prevState, snapshot)



    3. Демонтування (unmounting) — компонент видаляється з DOM

         Метод:

            3.1  componentWillUnmount()


‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾
    У React існує ще одна фаза життєвого циклу — ОБРОБКА ПОМИЛОК, але вона не є частиною стандартного циклу:
                                 монтування —→ оновлення —→ демонтування

    Ця фаза активується не за сценарієм нормального життєвого циклу компонента, а лише у випадку помилки
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────


    4. Обробка помилок (error handling) — фаза, яка обробляє помилки у дочірніх компонентах (додана у React 16.0 — 2017)

         Методи:

            4.1  static getDerivedStateFromError(error)

            4.2  componentDidCatch(error, info)

            4.3  render()                       —→  Щоб відобразити альтернативний інтерфейс

─────────────
            2.5  React порівнює старий Virtual DOM vs новий Virtual DOM   —→   Diffing

            2.6  React оновлює реальний DOM


‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾ ↓  ↓  ↓ ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾

                                        1. ФАЗА МОНТУВАННЯ (Mounting)

 Це перша фаза життєвого циклу React-компонента, під час якої компонент ВПЕРШЕ створюється, вставляється у віртуальний
 DOM та відображається на сторінці


 React переходить цю фазу, коли:

      ◦ відбувається первинний рендер сторінки — початкове завантаження, під час якого React відмальовує компоненти
        всередині <App />

      ◦ або коли динамічно додається новий компонент (наприклад, через умову)


 React самостійно запускає фазу монтування, щойно під час рендеру батьківського компонента (під час першого рендеру чи
 оновлення) виявляє, що новий дочірній компонент має вперше зʼявитися у віртуальному DOM


                                         ПЕРШИЙ ЕТАП ФАЗИ МОНТУВАННЯ:


 1.1  constructor(props) — ініціалізація стану (state), й опційно: зберігання props у state та прив'язка методів до this

      ЩО ЦЕ:
             ◦ Метод, який викликається першим під час створення компонента

             ◦ Використовується для ініцілізації початкового стану (state)

             ◦ За потреби — для роботи з вхідними параметрами (props) та прив'язки методів до this


      ДЛЯ ЧОГО:
             ◦ Ініціалізує state — створює об’єкт state і задає йому початкові значення, які ми вказали у конструкторі

             ◦ Може зчитувати props (властивості, які передаються в компонент ззовні)

                 В constructor ми можемо зберегти props у state й використати їх для обчислень або додаткової логіки
                 (не часто використовується, зазвичай працюють з props напряму в JSX)

             ◦ Може прив’язувати методи до this, якщо не використовуються стрілкові функції


      НЕ МОЖНА: Викликати setState() всередині constructor

‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾

                             МЕТОДИ У КЛАСОВОМУ КОМПОНЕНТІ Й ПРИВʼЯЗКА ДО ПОДІЙ

 ПРОБЛЕМА: У класовому компоненті методи, оголошені через function declaration, не мають автоматичного доступу до this

 ТОБТО: Якщо всередині цього методу ми звертаємося до this, а потім передаємо цей метод як обробник події у render()
                                                 ↓  ↓  ↓
                                      виникне помилка або undefined


  handleClick() {                    —→  оголошуємо метод через function declaration
    console.log(this.state.count);   —→  this буде undefined — помилка
  }

  render() {
    return (
      <button onClick={this.handleClick}>Click me</button>   —→ передаємо метод handleClick як обробник події
    )
  }


 РІШЕННЯ: Прив’язати метод до поточного this в constructor:

  Щоб this правильно працював у методі, потрібно прив’язати метод до поточного екземпляра компонента (тобто до this)

   constructor(props) {
     super(props);
     this.state = { count: 0 };

     this.handleClick = this.handleClick.bind(this);  —→  прив’язуємо handleClick до поточного екземпляра компонента
   }


 АЛЬТЕРНАТИВА: Писати методи через СТРІЛКОВІ ФУНКЦІЇ — вони автоматично прив’зані до this, тому додатково прив’язувати
               їх у constructor не потрібно

   handleClick = () => {             —→  сучасний підхід
     console.log(this.state.count);
   }


‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾

                                ПОДАЛЬШІ МЕТОДИ, ЯКІ МОЖНА РЕАЛІЗУВАТИ НА ЦІЙ ФАЗІ:


 1.2  static getDerivedStateFromProps(props, state) — викликається перед кожним рендером та оновлює state на основі
                                                      нових props

      ЩО ЦЕ:
             ◦ Статичний метод класу, який викликається перед кожним рендером компонента — і під час первинного
               монтування, і під час оновлення

             ◦ Використовується для синхронізації стану (state) з новими пропсами (props)


      ДЛЯ ЧОГО:
             ◦ Якщо компонент зберігає у своєму стані (state) значення, які залежать від пропсів, цей метод дозволяє
               оновити state, коли пропси змінюються

             ◦ Повертає новий об’єкт стану, який об’єднується з поточним state (або null, якщо оновлення не потрібно)


      ЯК ПРАЦЮЄ:
             ◦ Отримує два аргументи:
                 • props — нові пропси, які отримав компонент
                 • state — поточний стан компонента

             ◦ Порівнює пропси і стан, щоб визначити, чи потрібно оновити стан

             ◦ Повертає оновлений об’єкт стану або null


      КОЛИ ВИКОРИСТОВУЄТЬСЯ:

             Лише коли ми маємо у state значення, які залежать від пропсів, тож при кожному новому виклику render() є
             шанс, що тригером були нові пропси з батьківського елементу (або зміна state)

             Метод getDerivedStateFromProps(props, state) використовується щоб зловити ці дані й виконати додаткову
             логіку з ними до рендеру


      ЗБЕРІГАННЯ ПРОПСІВ У STATE:

             ◦ Загалом в React краще використовувати пропси напряму, особливо для відображення (в JSX) або для простих
               обчислень

             ◦ Зберігати пропси у state має сенс лише у специфічних випадках, зокрема:

                   • Коли потрібно виконати складну логіку обчислення значення, яке залежить від пропсів й це значення
                     використовується багаторазово в різних частинах компонента

                   • Або коли нам потрібно зберігати копію пропсів локально, щоб мати змогу змінювати її незалежно від
                     подальших оновлень зовнішніх пропсів


      ВАЖЛИВО:
             ◦ Метод не має доступу до this, оскільки статичний


      НЕ РЕКОМЕНДУЄТЬСЯ:
             ◦ Копіювати props у state без вагомої причини — це часто призводить до помилок і ускладнює підтримку коду


‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾

   1.3  render() — описує, що має відобразитися

      ЩО ЦЕ:
             ◦ Єдиний обов’язковий метод класового компонента — без нього React-компонент просто не працюватиме

             ◦ Викликається при кожному рендері компонента: як під час монтування, так і під час оновлення


      ДЛЯ ЧОГО:
             ◦ ГОЛОВНА МЕТА — визначити структуру інтерфейсу (HTML розмітку), яку має показати компонент

             ◦ React бере те, що повертає render() — один JSX елемент
               ↓
               Створює на його основі віртуальний DOM
               ↓
               І синхронізує з реальним DOM, оновлюючи лише те, що змінилося


      ВАЖЛИВО:
             ◦ render() НЕ ПОВИНЕН:

                   • змінювати стан (state) — всередині render() не повино бути виклику setState(), бо це змінить стан
                     і викличе повторний рендер (нескінченний цикл)

                   • або мати побічні ефекти — дії, які змінюють щось поза межами самого методу render(), наприклад:

                         ◦ робити мережеві запити (fetch)

                         ◦ записувати дані кудись (localStorage або SessionStorage)

                         ◦ викликати таймери, слухачі подій

                         ◦ змінювати глобальні змінні або DOM напряму

                    ЗА ЦІ ПОБІЧНІ ДІЇ ВІДПОВІДАЄ МЕТОД: componentDidMount()


             ◦ У render() ДОЗВОЛЕНО:

                   • використовувати this.props і this.state

                   • викликати інші методи для обчислення або підготовки даних

                   • використовувати умови (if, тернарні оператори) або логічні вирази, щоб показувати різні частини
                     інтерфейсу


───────────────────────────
   1.4  React порівнює старий virtual dom vs новий virtual dom   —→   Diffing

   1.5  REACT ОНОВЛЮЄ РЕАЛЬНИЙ DOM
───────────────────────────


   1.6  componentDidMount() — виконується після першого рендера, тут можна робити запити на сервер, тощо

      ЩО ЦЕ:
             ◦ Метод життєвого циклу React компонента, який викликається один раз — одразу після першого рендеру
               (тобто коли компонент вже вставлено в DOM)

             ◦ React гарантує, що цей метод буде викликано після того, як компонент зʼявився на сторінці


      ДЛЯ ЧОГО: Цей метод призначений для виконання побічних ефектів — дій, які не можна робити render():

             ◦ Робити запити на сервер (fetch, axios), щоб завантажити дані для компонента

             ◦ Підписуватися на зовнішні події

                    Зовнішні події — це дії, які відбуваються поза межами компонента, але можуть впливати на нього:

                        • resize — користувач змінює розмір вікна браузера

                        • click на документі або кнопці — користувач клікає поза компонентом або на щось глобальне

                        • scroll — користувач прокручує сторінку

                        • WebSocket повідомлення — сервер надсилає повідомлення в реальному часі

             ◦ Запускати таймери (setTimeout, setInterval)


      ВАЖЛИВО:
             ◦ У методі componentDidMount() зазвичай викликається setState(), щоб оновити стан компонента на основі
               отриманих даних (це спричинить повторний рендер)

             ◦ Не можна виконувати важкі синхронні операції, які блокують UI — всі довгі задачі варто виконувати
               асинхронно


                ┌──────────────────────────────────────────────────────────────────────────────────────────────────────┐
                                                         WebSocket

                    ЗВИЧАЙНИЙ ВИПАДОК (без WebSocket):

                      Коли ми хочемо отримати нові дані з сервера (наприклад, нові повідомлення), браузер має:

                          надіслати запит  —→  дочекатися відповіді  —→  показати результат

                      But if ми хочемо отримувати оновлення автоматично, без постійних запитів — нам потрібен WebSocket


                      ЩО ТАКЕ WEBSOCKET: це спеціальний протокол звʼязку між браузером і сервером, який дозволяє:

                         ◦ постійне з'єднання між клієнтом і сервером

                         ◦ сервер і браузер можуть надсилати повідомлення одне одному в будь-який момент

                         ◦ без перезавантажень і без нових запитів


                      Повідомлення в реальному часі означає, що як тільки на сервері зʼявляється щось нове, він
                      миттєво надсилає повідомлення у наш компонент

                      НАПРИКЛАД:

                       ◦ В чаті хтось написав повідомлення —→ сервер одразу надсилає його всім підключеним користувачам

                       ◦ У системі біржі — ціна акції змінилася —→ сервер надсилає нові значення в усі компоненти

                └──────────────────────────────────────────────────────────────────────────────────────────────────────┘


                                    ЯК ВІДБУВАЮТЬСЯ ЗАПИТИ ДО СЕРВЕРА В REACT


 1. Компонент спочатку рендериться без даних

      1.1  Коли компонент потрапляє в фазу монтування (коли React вперше створює компонент), викликається метод render()

      1.2  На цьому етапі дані з сервера ще не отримані, тому компонент рендервться на основі того, що є в state на
           момент першого рендера

      1.3  Це фаза очікування, на якій ми вирішуємо, що показувати, поки дані не завантажились

             ◦ Loader (простий запис)  —→  <p>Loading...</p>

             ◦ Скелетон — сірі блоки, які імітують майбутній вміст

             ◦ Порожній список — <ul></ul> без елементів <li>

             ◦ Спінер — анімований індикатор завантаження (кружок або точка, що обертається чи пульсує)


 2. Після першого рендера викликається метод componentDidMount()

      2.1  У цьому методі зазвичай відбувається запит на сервер (fetch)

      2.2  Запит — це асинхронна операція, вона виконується в фоновому режимі і не блокує роботу інтерфейсу


 3. Оновлення стану після отримання даних

      3.1  Коли сервер повертає дані, ми викликаємо this.setState({data}) у componentDidMount()

      3.2  setState() оновлює стан компонента і автоматично запускає повторний render()


 4. React знову рендерить компонент — уже з даними, отриманими з сервера

      4.1  Тепер у методі render() вже є актуальні дані в state

      4.2  React створює нову JSX-структуру на основі цих даних

      4.3  Відбувається оновлення Virtual DOM, а потім — реального DOM


 ЧОМУ ЦЕ ВАЖЛИВО:

   ◦ render() має бути чистою функцією: він тільки створює розмітку на основі props і state

   ◦ Запити й зміни стану — це побічні ефекти, їх не можна робити у render(), щоб уникнути нескінченних циклів і помилок



ПРИКЛАД:

class NewsList extends React.Component {
  state = {                                                    (1) Початковий state: articles: []  —→  список порожній
    isLoading: true,
    articles: []
  };

  render() {                                                   (2) Перший виклик render(): React бачить, що isLoading === true і повертає loader
    if (this.state.isLoading) {                                    ↓
      return <p>Loading...</p>;                                    Це і є ВІДМАЛЬОВУВАННЯ БЕЗ ДАНИХ — ми самі визначаємо, що показати, поки дані ще не прийшли
    }

    return (                                                   (5) Коли isLoading: false і articles заповнені  —→  render повертає повноцінний компонент зі списком
      <ul>
        {this.state.articles.map((article) => (
          <li key={article.id}>{article.title}</li>
        ))}
      </ul>
    );
  }

  async componentDidMount() {                                   (3) Після першого рендера викликається componentDidMount() —→ тут ми робимо запит до сервера (fetch)
    try {
      const res = await fetch('/api/articles');
      const data = await res.json();

      this.setState({ articles: data, isLoading: false });      (4) Коли дані приходять викликаємо setState(): оновлюємо articles і вимикаємо isLoading
    } catch (err) {                                                                                            ↓
      console.error(err);                                                                                      це викликає повторний render()
    }
  }
}



‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾ ↓  ↓  ↓ ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾

                                        2. ФАЗА ОНОВЛЕННЯ (Updating)

 Це друга фаза життєвого циклу компонента, яка відбувається щоразу, коли React приймає рішення перерендерити компонент
 у відповідь на зміну стану (state) або вхідних параметрів (props)

 React переходить у цю фазу, коли:

      ◦ Викликається this.setState() — оновлюється локальний стан компонента, що вимагає повторного рендеру

      ◦ Компонент отримує нові props — наприклад, батьківський компонент передає нові дані

      ◦  Відбувається оновлення батьківського компонента — React перерендерює все піддерево, включно з дочірніми
         компонентами


 Під час фази оновлення React порівнює новий стан і пропси з попередніми значеннями, і на основі цього вирішує, чи
 потрібно оновити DOM


                                    МЕТОДИ, ЯКІ МОЖНА РЕАЛІЗУВАТИ НА ЦІЙ ФАЗІ:


   2.1  static getDerivedStateFromProps(props, state) — викликається перед кожним рендером та оновлює state на основі
                                                      нових props

‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾

   2.2  shouldComponentUpdate(nextProps, nextState) — контроль, чи потрібно оновлювати компонент

      ЩО ЦЕ:
             ◦ Це метод життєвого циклу, який викликається після getDerivedStateFromProps, але перед render()

             ◦ Дозволяє контролювати, чи потрібно React перерендерювати компонент при зміні props або state

             ◦ Повертає:
                   • true (за замовчуванням) — тоді render() викликається

                   • або false — тоді оновлення пропускається, і компонент не рендериться знову


      ДЛЯ ЧОГО:
             ◦ Оптимізація продуктивності — уникнення зайвих рендерів

             ◦ Визначення умов, за яких компонент має оновитися, а коли можна пропустити ререндер


      ЯК ПРАЦЮЄ:
             ◦ Метод приймає два аргументи:

                   • nextProps — нові пропси, які щойно надійшли
                   • nextState — новий стан, який встановлюється перед ререндером

             ◦ Всередині методу ми порівнюємо нові пропси/стан із поточними (this.props, this.state)

             ◦ Якщо різниця є — повертаємо true, і компонент оновлюється

             ◦ Якщо зміни незначні або не впливають на вміст — повертаємо false


      ПРИКЛАД: компонент оновлюється лише якщо зміниться певний пропс або поле стану

             shouldComponentUpdate(nextProps, nextState) {
               return nextProps.value !== this.props.value || nextState.count !== this.state.count;
             }


      ВИКОРИСТАННЯ:
             ◦ У складних компонентах, де рендеринг важкий або великий DOM

             ◦ Якщо компонент отримує багато пропсів, але лише деякі з них впливають на відображення



      ВАЖЛИВО:
             ◦ Метод не обов’язковий — якщо його немає, React завжди виконує ререндер

             ◦ Не можна змінювати стан (this.setState) у цьому методі — це має бути чиста функція, яка лише порівнює
               пропси та стан й повертає true або false

             ◦ Якщо в компоненті небагато логіки або рендер швидкий — краще не ускладнювати код shouldComponentUpdate()


‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾

   2.3  render() — описує, що має відобразитися

‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾

   2.4  getSnapshotBeforeUpdate(prevProps, prevState) — збереження стану DOM перед оновленням

      ЩО ЦЕ:
             ◦ Це метод життєвого циклу, який викликається після render(), але перед тим, як зміни зʼявляться в
               реальному DOM

             ◦ Дає можливість зняти знімок (snapshot) поточного стану DOM до оновлення — наприклад:

                   • координати прокрутки (scroll position)

                   • розміри елемента (width, height) для плавної анімації

                   • положення курсора тощо


      ДЛЯ ЧОГО: Щоб зберегти будь-які значення, які буде втрачено під час оновлення DOM, наприклад:

             ◦ Координати скролу, щоб відновити прокрутку після оновлення

                  Якщо в компоненті є прокручуваний контейнер (наприклад, чат), можна зберегти поточну позицію
                  прокрутки і після оновлення відновити її, щоб користувач не перескакував у інше місце


             ◦ Положення елемента до анімації

                  Якщо потрібно анімувати зміну розміру або позицію елемента, варто зафіксувати його початкові
                  координати та розміри, щоб потім плавно перейти до нового стану

                  ПРОБЛЕМА: Коли React оновлює DOM, елемент одразу перестрибує на нове місце, і це виглядає різко

                  РІШЕННЯ: Використати метод getSnapshotBeforeUpdate щоб перед оновленням зберегти стару позицію
                           елемента (де він був до оновлення)

‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾
  ТОБТО:

    1. getSnapshotBeforeUpdate()  —→  перед оновленням ми зберігаємо поточне положення елемента (стару позицію)

    2. render()  —→  React оновлює DOM, і елемент миттєво переміщується у нову позицію

    3. componentDidUpdate()  —→  одразу після оновлення ми порівнюємо стару позицію з новою

       Й щоб не було стрибка, тимчасово зсуваємо елемент назад до старої позиції (через CSS-transform):

       Миттєво зсуваємо елемент назад у стару позицію — без анімації!
       Це робиться через CSS transform, але без transition, тому зміна непомітна для ока

       Тобто зсув назад на стару позицію виконується миттєво і без анімації (в одному кадрі,
       і око не встигає цього зафіксувати)

       Потім, у наступному кадрі, ми додаємо CSS-переход (transition) і скидаємо transform
       Це запускає плавну анімацію з позиції "назад" у нову позицію, яка вже є в DOM

                                  ↓  ↓  ↓

           1. React оновлює DOM → елемент на новому місці

           2. Ми через transform ховаємо це оновлення, повертаючи візуально елемент назад

           3. Далі анімуємо transform до 0 — плавний перехід

‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾

             ◦ Поточне фокусування, яке потрібно перенести або зберегти

                  Якщо користувач вводить текст або взаємодіє з формою, оновлення компонента може скинути фокус або
                  положення курсора

                  Збереження цих даних дає змогу відновити фокус або позицію курсора в методі componentDidUpdate(),
                  щоб не порушувати UX


                  Виклик рендеру, який може призвести до втрати фокуса або курсора, може відбуватись і під час вводу
                  тексту в <input>

                  Наприклад:

                  Оновлення стану (setState) у компоненті — якщо ми оновлюємо стан при кожній зміні поля (onChange),
                  React повторно викликає render(), що може призвести до оновлення DOM і втрати фокуса або позиції
                  курсора


      ЯК ПРАЦЮЄ:
             ◦ Метод викликається із двома аргументами:

                   • prevProps — старі пропси до оновлення
                   • prevState — старий стан до оновлення

             ◦ Повертає будь-яке значення (або null), яке передається в componentDidUpdate як третій аргумент (snapshot)


      ВАЖЛИВО:
             ◦ Метод не обов’язковий, використовується лише в рідкісних випадках, коли потрібно точно відстежити стан
               DOM перед змінами

             ◦ Не можна викликати setState() в цьому методі


───────────────────────────
   2.5  React порівнює старий virtual dom vs новий virtual dom   —→   Diffing

   2.6  REACT ОНОВЛЮЄ РЕАЛЬНИЙ DOM
───────────────────────────


   2.7  componentDidUpdate(prevProps, prevState, snapshot) — метод, який виконується після оновлення компонента

        Подібно до componentDidMount(), у цьому методі розміщують усі побічні дії, які потрібно виконати після
        оновлення компонента

              ◦ componentDidMount() виконується ОДНОРАЗОВО після першого відмалювання компонента — тут зазвичай
                роблять початкові запити на сервер, підписки на зовнішні події тощо

              ◦ componentDidUpdate() виконується КОЖНОГО РАЗУ, коли компонент оновлюється (після зміни props або state)

                  У ньому можна:
                     • робити нові запити, які потрібні після змін
                     • оновлювати DOM
                     • запускати анімації або
                     • або виконувати інші побічні ефекти


      ЩО ЦЕ:
             ◦ Метод життєвого циклу компонента, який викликається відразу після того, як компонент оновився
               (після виклику render() та оновлення DOM)

             ◦ Отримує у аргументах:

                   • попередні пропси (prevProps)

                   • попередній стан (prevState)

                   • і (опційно) знімок з getSnapshotBeforeUpdate()


      ДЛЯ ЧОГО: Цей метод призначений для виконання побічних ефектів — додаткових дій, які потрібно зробити після
                оновлення інтерфейсу:

             ◦ Використовується для роботи з DOM — наприклад:

                   • запуску анімацій

                   • фокусування елементів

                         Наприклад, якщо після оновлення хочемо, щоб курсор автоматично став у певне поле вводу (input),
                         або щоб якась кнопка отримала фокус для зручності користувача

                   • відновлення позиції прокрутки (щоб не стрибав список чатів чи стрічка новин)


             ◦ Дозволяє порівнювати попередні пропси/стан з поточними, щоб визначити, чи потрібно виконувати додаткові
               запити на сервер у відповідь на зміни. Наприклад:

                   • Завантажувати нові дані (якщо змінилися параметри фільтрації, сортування, сторінка пагінації тощо)

                   • Оновлювати повʼязані ресурси
                     Наприклад, завантажити нові коментарі до статті, якщо змінилася стаття

                   • Відправляти аналітику чи статистику
                     Наприклад, при зміні деяких параметрів, якщо потрібно відслідковувати дії користувача


             ◦ Обробка snapshot з getSnapshotBeforeUpdate() — наприклад:

                   • відновити позицію прокрутки
                   • зберегти курсор або фокус


      ЯК ПРАЦЮЄ:
             ◦ Метод викликається після оновлення компонента

             ◦ Можна викликати setState(), але обов’язково з умовою, щоб уникнути нескінченних оновлень

             ◦ Можна взаємодіяти з DOM-елементами, оскільки реальний DOM вже синхронізовано з віртуальним


      ПРИКЛАД ВИКОРИСТАННЯ:
             ◦ Відновлення позиції прокрутки у чаті після отримання нових повідомлень

             ◦ Запуск анімації

             ◦ Відправлення нового запиту на сервер, якщо змінилися певні пропси


      ВАЖЛИВО:
             ◦ Не викликати setState() без умов — це призведе до нескінченного циклу рендерів

             ◦ Метод виконується після повного оновлення DOM — можна безпечно взаємодіяти з DOM-елементами



‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾ ↓  ↓  ↓ ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾

                                        3. ФАЗА ДЕМОНТУВАННЯ (Unmounting)

 Це остання фаза життєвого циклу компонента, яка настає, коли компонент більше не потрібен і має бути вилучений із DOM


 React переходить цю фазу, коли:

      ◦ Компонент вилучається з розмітки (наприклад, через умову)

      ◦ Коли змінюється маршрут у SPA, і попередній компонент більше не відображається

             • Маршрутизація в SPA — це імітація переходу між сторінками, реалізована через динамічну заміну
               компонентів, без перезавантаження браузера

             • Зовні все виглядає як класичний перехід між сторінками (URL змінюється)

             • Але насправді React просто підмінює компоненти, які відповідають цим маршрутам


      ◦ Класичні приклади демонтування:

             • При перезавантаженні сторінки  —→  знищується все дерево компонентів

             • При переході на іншу сторінку (у SPA)  —→  знищується поточне дерево, часто за винятком Header, Footer

             • При закритті модального вікна  —→  компонент модального вікна видаляється з DOM

             • При видаленні елемента зі списку  —→  React видаляє відповідний компонент-елемент списку



                        ОСНОВНИЙ І ЄДИНИЙ МЕТОД, ЯКИЙ МОЖНА РЕАЛІЗУВАТИ НА ЦІЙ ФАЗИ:

   3.1  componentWillUnmount() — очищення перед видаленням

      ЩО ЦЕ:
             ◦ Метод життєвого циклу, який викликається безпосередньо перед тим, як компонент буде видалено з DOM

             ◦ Це останній шанс виконати "прибирання" (to cleanup), тобто:

                   • зупинити все, що було запущено компонентом (таймери, обробники подій, запити тощо)

                   • звільнити ресурси, щоб уникнути витоків памʼяті

             ◦ Якщо після зникнення компонента залишити:

                   • працюючі таймери

                   • зовнішні обробники подій
                     (event listeners, які не належать самому компоненту, а додаються вручну до зовнішніх елементів DOM)

                   • відкриті WebSocket-и

                   • або активні запити на сервер

               Вони продовжать працювати у памʼяті, навіть якщо сам компонент уже не існує на сторінці


               Це призведе до витрат ресурсів, повільнішої роботи, або помилок (наприклад, коли
               таймер спробує викликати setState(), а компонента вже немає)

               Витрати ресурсів — це використання оперативної памʼяті (RAM), процесора (CPU), мережі
               або інших обчислювальних ресурсів компʼютера або браузера, які:

                   • не приносять користі (наприклад, компонент уже не видно, але таймер усе ще працює)

                   • або використовуються неефективно, бо ми забули прибрати (cleanup) після компонента


      ДЛЯ ЧОГО: Використовується для очищення всього, що було створено компонентом, наприклад:

             ◦ Скасування запитів на сервер, які ще не завершилися (наприклад, через AbortController)

             ◦ Відписка від зовнішніх потоків даних: WebSocket, EventSource тощо

             ◦ Скасування таймерів (clearInterval, clearTimeout)

             ◦ Видалення зовнішніх слухачів подій (наприклад, через window.removeEventListener)

             ◦ Звільнення ресурсів, створених сторонніми бібліотеками (наприклад: графіки, плагіни)


      ВАЖЛИВО:
             ◦ React автоматично не очищує побічні ефекти (додаткових ді), які були додані у componentDidMount() або
               componentDodUpdate()

             ◦ Усе, що було було створено у цих двох методах й потребує очищення, має бути видалено вручну у
               componentWillUnmount()

             ◦ Якщо цього не зробити, можуть виникнути:

                   • витоки памʼяті

                   • помилки при спробі оновити неіснуючий компонент

                   • некоректна поведінка інтерфейсу



‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾ ↓  ↓  ↓ ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾

                                    4. ФАЗА ОБРОБКИ ПОМИЛОК (Error Handling)


 У React існує ще одна фаза життєвого циклу — ОБРОБКА ПОМИЛОК, але вона не є частиною стандартного циклу:
                                 монтування —→ оновлення —→ демонтування

 Ця фаза активується не за нормальним сценарієм життєвого циклу компонента, а лише коли в одному з дочірніх компонентів
 виникає помилка

 Це аварійна фаза, яка дає змогу безпечно обробити помилку та запобігти падінню всього застосунку


 Фаза обробки помилок у React не активується автоматично — щоб вона працювала, потрібно використати спеціальний
 компонент — ErrorBoundary


‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾

 <ErrorBoundary> — це React-класовий компонент, який дозволяє:

      ◦ Перехопити помилки, що виникли у render(), в constructor() або у методах життєвого циклу дочірніх компонентів

      ◦ Показати резервний інтерфейс (fallback UI) замість краху всієї програми

      ◦ Зібрати інформацію про помилку (логування, аналітика)

 Це єдиний спосіб активувати фазу обробки помилок


 ЛОВИТЬ:

      ◦ Помилки у render()

      ◦ Помилки в constructor

      ◦ Помилки в componentDidMount, componentDidUpdate

      ◦ Помилки в дочірніх компонентах (що знаходяться всередині ErrorBoundary)


 НЕ ЛОВИТЬ:

      ◦ Синтаксичні помилки

      ◦ Помилки у обробниках подій (onClick, onChange тощо)

      ◦ Помилки в асинхронних колбеках (наприклад, в setTimeout, fetch) — їх треба ловити через try...catch


 ЧОМУ ЦЕ ВАЖЛИВО:

       Якщо React-компонент викидає помилку без Error Boundary — усе дерево компонентів падає, і користувач бачить
       пусту або зламану сторінку

       ErrorBoundary дозволяє:

           ◦ зберегти інтерфейс хоча б частково

           ◦ надати повідомлення користувачу

           ◦ зібрати інформацію про помилку


 ЯК ПРАЦЮЄ:

  1. Ми створюємо свій класовий компонент ErrorBoundary
‾‾‾‾‾

    class ErrorBoundary extends React.Component {
      state = { hasError: false };

      static getDerivedStateFromError(error) {
        return { hasError: true };                  —→  Оновлюємо state, щоб у render() показати запасний UI
      }

      componentDidCatch(error, info) {
        console.error("Помилка:", error, info);     —→  Логуємо помилку: у dev — в консоль, в prod — на сервер
      }

      render() {
        if (this.state.hasError) {                 —→  Спрацьовує умова відображення запасного UI

          return <h1>Something went wrong</h1>;    —→  Якщо помилка — показуємо fallback UI
        }
        return this.props.children;                —→  Якщо помилки не було — показуємо уcі компоненти, які ми огорнули в ErrorBoundary)
      }
    }

    this.props.children — це вміст між відкриваючим і закриваючим тегом компонента, наприклад: <ErrorBoundary>



  2. Потім огортаємо у нього інший компонент чи коспоненти
‾‾‾‾‾
     ↓ ↓ ↓

 ЩО ЗАЗВИЧАЙ ОГОРТАЄТЬСЯ:

   1. Увесь застосунок (глобально) — найчастіше огортають весь <App />

          <ErrorBoundary>
            <App />
          </ErrorBoundary>

      Це гарантує, що будь-яка неочікувана помилка в інтерфейсі (навіть глибоко в дочірніх компонентах) не зламає
      всю сторінку — буде показано fallback UI


   2. Великі секції інтерфейсу окремо — огортають <MainContent/>

          <Header />
          <ErrorBoundary>
            <MainContent />
          </ErrorBoundary>
          <Footer />

      Якщо в MainContent станеться помилка, Header і Footer залишаться відображеними
      Це краще User Experience, ніж коли все зникає через одну помилку


   3. Небезпечні компоненти (локально)

      Помилка може бути очікуваною або ймовірною, наприклад:

         ◦ список із багатьма сторонніми даними

         ◦ форма, що виконує складну перевірку

         ◦ інтеграція з бібліотекою (наприклад, графіки, мапи)


          <ErrorBoundary>
            <Chart data={stats} />    chart — графік, діаграма
          </ErrorBoundary>

      Це дозволяє ізолювати помилки лише в цьому компоненті — інший інтерфейс продовжує працювати


‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾

  React переходить у фазу обробки помилок, якщо в одному з дочірніх компонентів виникла помилка

      ◦ render() – помилка під час генерації JSX-розмітки

      ◦ constructor() – помилка під час ініціалізації компонента

      ◦ componentDidMount() – помилка після монтування (наприклад, при запиті на сервер)

      ◦ componentDidUpdate() – помилка після оновлення (наприклад, при оновленні DOM, обчисленнях, анімаціях)


  Фаза обробки помилок (Error Boundary) в React не активується, якщо помилка була зловлена всередині try...catch


                                    МЕТОДИ, ЯКІ МОЖНА РЕАЛІЗУВАТИ НА ЦІЙ ФАЗІ:


   4.1 static getDerivedStateFromError(error) — оновлення стану компонента при помилці

       ЩО ЦЕ:
             ◦ Статичний метод класу React-компонента, який викликається у компоненті <ErrorBoundary>,
               коли виникає помилка в одному з його дочірніх компонентів

             ◦ Метод не має доступу до this, бо є статичним


       ДЛЯ ЧОГО:

             ◦ Використовується для оновлення стану компонента —→ щоб у render() спрацювала умова помилки —→
               й відобразився запасний інтерфейс (fallback UI)

             ◦ Працює разом із componentDidCatch, який відповідає за побічні дії — наприклад, логування помилки


       ЯК ПРАЦЮЄ:

             ◦ Отримує помилку в аргументі — error

             ◦ Повертає об'єкт з частковим оновленням стану — { hasError: true }

             ◦ React автоматично об’єднує цей об’єкт з поточним state (виконує shallow merge — неглибоке об’єднання):

                    • Оновлює тільки ті поля, які ми повертаємо
                    • Не змінює решту полів, які вже є в state компонента


       КОЛИ ВИКОРИСТОВУЄТЬСЯ:

             ◦ В компонентах-обгортках (Error Boundaries), які захищають інтерфейс від падінь через помилки в дочірніх
               компонентах


       ВАЖЛИВО:
             ◦ Не виконує побічних ефектів (запитів, логування) — для цього слід використовувати метод componentDidCatch

             ◦ Не можна викликати setState у цьому методі — потрібно повертати новий стан

───────────────────────────

   4.2 componentDidCatch(error, info) — обробка побічних ефектів після помилки

       ЩО ЦЕ:
             ◦ Це метод життєвого циклу класового компонента, який викликається, коли в одному з дочірніх компонентів
               сталася необроблена помилка

             ◦ Використовується разом із getDerivedStateFromError():

                    • getDerivedStateFromError() — відповідає за оновлення стану

                    • а componentDidCatch() — за побічні ефекти (логування, повідомлення, тощо)

             ◦ Не статичний, має доступ до this —→ можна викликати setState(), робити запити


             МАЄ ДВА АРГУМЕНТИ:

                  • error — сама помилка (як у try...catch)
                   ‾‾‾‾‾‾
                         ◦ Це сама помилка, яка виникла в дочірньому компоненті (TypeError, ReferenceError тощо)

                         ◦ Виглядає як помилка у try...catch — має message, name, stack


                  • info — об’єкт з одним полем componentStack, який містить додаткову інформацію про те, де сталася
                   ‾‾‾‾‾   помилка

                         {
                           componentStack: '↳ MyComponent\n ↳ <App>\n ↳ <ErrorBoundary>'
                         }

                         componentStack — це стек компонентів React, які були активні в момент помилки


                         ВИКОРИСТАННЯ info.componentStack:

                             ◦ Щоб зрозуміти де саме в ієрархії React сталася помилка

                             ◦ Щоб надіслати інформацію про помилку на сервер або вивести в консолі

                             ◦ Щоб допомогти в дебагінгу: побачити шлях до компонента, який впав


                          ПРИКЛАД:

                              componentDidCatch(error, info) {
                                console.error("Error:", error.message);
                                console.error("Component stack:", info.componentStack);
                              }

────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
                                                    СТЕК

  ◦ Стек — це послідовність викликів (функцій або компонентів), які накладаються один на одного під час виконання коду

  ◦ Працює за принципом LIFO (Last In, First Out) — останнє, що було викликане, завершується першим

  ◦  У випадку з помилками — дозволяє побачити, які компоненти React викликали один одного, поки не сталася помилка

      • Найглибший (останній викликаний) компонент, у якому виникла помилка, буде першим у списку

      • Дозволяє побачити, в якому компоненті та вкладеності виникла помилка

────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────

       ДЛЯ ЧОГО:
             ◦ Логування помилок:
                   • виведення в консоль (console.error)
                   • відправлення логів на сервер (аналітика)

             ◦ Аналіз причин помилки — через info.componentStack


       ВАЖЛИВО:
             ◦ componentDidCatch() працює тільки в класових компонентах — у функціональних для цього використовують
               хук useErrorBoundary() з бібліотек

             ◦ Цей метод не запобігає самій помилці — лише дозволяє її обробити


───────────────────────────

   4.3  Render()

   4.4  React порівнює старий virtual dom vs новий virtual dom   —→   Diffing

   4.5  REACT ОНОВЛЮЄ РЕАЛЬНИЙ DOM

──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────*/